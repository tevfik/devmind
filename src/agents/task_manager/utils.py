import logging
from typing import List, Dict, Optional, Any
from datetime import datetime
import git
from agents.agent_base import Task, TaskStatus, logger
from tools.forge.tool import ForgeTool


class YaverClient:
    """Mock Client for CLI mode since api_client module is missing"""

    def add_comment(self, task_id, content, author="Yaver Worker"):
        logger.info(f"[{author}] Comment on {task_id}: {content}")

    def update_task_status(self, task_id, status):
        logger.info(f"Task {task_id} status updated to: {status}")


def update_task_status(
    tasks: List[Task],
    task_id: str,
    status: TaskStatus,
    result: Optional[str] = None,
    error: Optional[str] = None,
) -> List[Task]:
    """Update task status"""
    for task in tasks:
        if task.id == task_id:
            task.status = status
            if result:
                task.result = result
            if error:
                task.error = error
            if status == TaskStatus.COMPLETED:
                task.completed_at = datetime.now()
            break

    return tasks


def commit_and_push_bundle(state: Dict[str, Any], repo_path: str):
    """
    Commits staged changes, pushes to remote, handles PRs, and reacts to comments.
    Executes only once per session/task bundle.
    """
    logger.info("Executing final commit bundle...")
    tasks = state.get("tasks", [])
    if not tasks:
        return

    # Use the first task (Main Task) for the commit message usually
    # Or find the reactive task (originating_comment_id)
    main_task = tasks[0]
    reactive_task = next(
        (t for t in tasks if getattr(t, "originating_comment_id", None)), main_task
    )

    repo = git.Repo(repo_path)
    commit_msg = f"fix: {reactive_task.title} (Task {reactive_task.id[:8]})"

    # 1. Commit
    if repo.is_dirty() or len(repo.index.diff("HEAD")) > 0:
        try:
            # Use git binary directly to handle merge states (MERGE_HEAD) correctly
            repo.git.commit("-m", commit_msg)
            logger.info(f"Committed bundle: {commit_msg}")
        except Exception:
            # Fallback to GitPython index commit if binary fails or for empty commits
            # Note: This might lose merge parents if in merge state
            repo.index.commit(commit_msg)
            logger.info(f"Committed bundle (fallback): {commit_msg}")
    else:
        logger.info("No changes to commit.")
        return

    # 2. Push & Handle Branches
    current_branch = repo.active_branch.name

    try:
        # Check if we need to push (default yes for social developer)
        logger.info(f"Pushing {current_branch} to remote...")
        repo.git.push("-u", "origin", current_branch)
    except Exception as push_err:
        logger.warning(f"Push failed: {push_err}")
        # Handle non-fast-forward (diverged branch)
        if "non-fast-forward" in str(push_err) or "rejected" in str(push_err):
            try:
                logger.info("Attempting rebase to resolve divergence...")
                repo.git.pull("--rebase", "origin", current_branch)
                repo.git.push("-u", "origin", current_branch)
                logger.info("âœ… Rebase and push successful.")
            except Exception as rebase_err:
                logger.error(f"Rebase failed: {rebase_err}")
                # Safe fallback: Only force push if it is a 'fix/' branch managed by us
                if current_branch.startswith("fix/"):
                    logger.warning("âš ï¸ Force pushing to owned fix branch...")
                    repo.git.push("-u", "origin", current_branch, force=True)
                else:
                    logger.error("Cannot push changes.")

        # 3. Create/Update PR Logic
        active_pr = state.get("active_pr")
        forge = ForgeTool(repo_path=repo_path)

        if not active_pr:
            try:
                # Check if PR exists first (maybe created externally or just missed)
                # Gitea/Github usually returns existing if we try to create, but let's be safe
                # We don't have a direct "find_pr_by_branch" exposed in ForgeTool convenient wrapper yet,
                # but create_pr usually fails if exists or returns it.
                # Let's try to create.
                pr_title = f"{main_task.title}"
                pr_body = f"Autogenerated by Yaver Agent.\n\nTask: {main_task.title}\nID: {main_task.id}"

                logger.info(f"Creating PR for {current_branch}...")
                active_pr = forge.run(
                    "create_pr",
                    title=pr_title,
                    body=pr_body,
                    head=current_branch,
                    base="main",
                )

                if active_pr:
                    logger.info(f"âœ… Created PR #{active_pr.get('number')}")
                    state["active_pr"] = active_pr
            except Exception as pr_err:
                logger.warning(f"Failed to create PR (might already exist): {pr_err}")
                # Try to fetch it? for now just ignore.

        # 4. Aesthetic Reaction (Eyes -> Thumbs Up)
        originating_comment_id = getattr(reactive_task, "originating_comment_id", None)
        if originating_comment_id:
            try:
                forge = ForgeTool(repo_path=repo_path)
                forge.run(
                    "add_reaction", issue_id=originating_comment_id, reaction="+1"
                )
                logger.info(
                    f"Added success reaction (+1) to comment {originating_comment_id}"
                )

                # Also reply with a summary comment
                staged_files = state.get("staged_files", [])
                summary_body = f"ðŸš€ **Fix Deployed**\n\nI have addressed the feedback with the following changes:\n"
                for f in staged_files:
                    summary_body += f"- `{f}`\n"
                summary_body += f"\nCommit: `{commit_msg}`"

                if active_pr:
                    pr_id = active_pr.get("number") or active_pr.get("id")
                    forge.run("comment_issue", issue_id=pr_id, body=summary_body)

            except Exception as e:
                logger.warning(f"Failed to post aesthetic reaction/comment: {e}")

    except Exception as push_err:
        logger.error(f"Push failed: {push_err}")
